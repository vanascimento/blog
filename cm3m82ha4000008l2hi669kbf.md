---
title: "Guia para Estender a API Kubernetes: Controle de Recursos do Cluster Usando Webhooks"
seoTitle: "Guia para Extender API Kubernetes com Webhooks"
seoDescription: "Use webhooks para estender a API Kubernetes, gerenciar recursos do cluster e aplicar pol√≠ticas automaticamente para conformidade e controle"
datePublished: Sun Nov 17 2024 23:22:45 GMT+0000 (Coordinated Universal Time)
cuid: cm3m82ha4000008l2hi669kbf
slug: guia-para-estender-a-api-kubernetes-controle-de-recursos-do-cluster-usando-webhooks
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1731885705286/32fe8861-847c-4c0b-8dbb-fb3f376bd807.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1731885722516/efdbe053-1269-4916-a6cc-05495ef8c866.png
tags: aws, golang, kubernetes, gcp, eks

---

# Introdu√ß√£o

Kubernetes se consolidou como a principal plataforma de orquestra√ß√£o de containers, permitindo que aplica√ß√µes sejam executadas com total abstra√ß√£o das m√°quinas que fornecem os recursos computacionais. Essa flexibilidade, por√©m, pode trazer desafios significativos, especialmente em termos de custos e conformidade no ambiente tecnol√≥gico. Definir pol√≠ticas de uso de recursos diretamente com os desenvolvedores nem sempre √© suficiente para garantir que essas diretrizes sejam seguidas.

Felizmente, a extensibilidade do Kubernetes nos permite ir al√©m. Atrav√©s de webhooks, podemos interceptar altera√ß√µes em recursos criados, editados ou removidos dentro do cluster, permitindo a implementa√ß√£o autom√°tica de pol√≠ticas personalizadas.

Neste post, vamos construir, de forma pr√°tica, um interceptador para controlar altera√ß√µes em deployments, garantindo que pol√≠ticas espec√≠ficas sejam obedecidas, como:

* **Limite de r√©plicas:** nenhum deployment pode ter mais de duas r√©plicas.
    
* **Restri√ß√£o de recursos:** containers n√£o podem requisitar mais de 100mCPU ou 250Mi de mem√≥ria.
    
* **Aplica√ß√£o em escopo espec√≠fico:** as regras devem se aplicar somente ao namespace *production*.
    

Acompanhe o passo a passo para implementar essas pol√≠ticas de maneira eficiente e automatizada no seu cluster Kubernetes.

# Requisitos

1. Cluster Kubernetes com acesso via kubectl
    
2. Tunnel [NGROK](https://ngrok.com/) para expormos nosso localhost ao cluster kubernetes.
    

# Roadmap

* **Configurar um webhook no namespace *production***: O webhook ser√° respons√°vel por interceptar todas as solicita√ß√µes relacionadas a recursos do tipo *deployment* na API version `v1` do grupo `apps`, garantindo que cada altera√ß√£o passe por valida√ß√£o antes de ser aplicada.
    
* **Desenvolver um microservi√ßo em Go**: Criar um microservi√ßo dedicado com um endpoint espec√≠fico para receber as requisi√ß√µes de admiss√£o do webhook. Este endpoint ser√° respons√°vel por processar as valida√ß√µes necess√°rias e retornar a aprova√ß√£o ou rejei√ß√£o conforme as pol√≠ticas estabelecidas.
    

# Controle de admiss√£o

O Kubernetes oferece um recurso chamado **ValidatingWebhookConfiguration**, que permite configurar webhooks para serem acionados sempre que o cluster receber uma solicita√ß√£o de admiss√£o, ou seja, altera√ß√µes em recursos dentro do cluster. Nesse recurso, √© poss√≠vel especificar o webhook a ser invocado e os par√¢metros que determinam quando e como ele ser√° executado.

Para implementar essa configura√ß√£o, crie um arquivo chamado `ValidatingWebhook.yaml` com o seguinte conte√∫do:

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: deployment-validation
  namespace: production
webhooks:
  - name: "deployment-validation.production.svc"
    namespaceSelector:
      matchExpressions:
        - key: kubernetes.io/metadata.name
          operator: In
          values: ["production"]
    rules:
      - operations: ["CREATE", "UPDATE", "DELETE"]
        apiGroups: ["apps"]
        apiVersions: ["v1"]
        resources: ["deployments"]
        scope: "Namespaced"
    clientConfig:
      url: [URL-NGROK]
    admissionReviewVersions: ["v1"]
    sideEffects: None
    timeoutSeconds: 30
```

Neste manifesto, estamos detalhando os requisitos descritos no item 1 do nosso roadmap. Para aplicar essa configura√ß√£o no cluster, execute o comando abaixo (lembre-se de substituir pela URL gerada pelo seu *ngrok*):

```bash
kubectl apply -f ValidatingWebhook.yaml
```

Confirme que o webhook foi criado com o seguinte comando

```bash
kubectl get ValidatingWebhookConfiguration 
```

O retorno dever√° ser algo parecido com:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1731883235806/240747c1-c022-44d7-9ecb-7135907dee8e.png align="center")

Com isso, nosso webhook est√° devidamente configurado, e todas as solicita√ß√µes que atendam aos crit√©rios definidos ser√£o interceptadas. Para validar sua funcionalidade, vamos testar criando um *deployment* do Nginx. Crie um arquivo chamado `deployment-nginx.yaml` com o seguinte conte√∫do:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  namespace: production
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:latest
          ports:
            - containerPort: 80
          resources:
            requests:
              cpu: 50m
              memory: 200Mi
```

Execute o seguinte comando para criar o recurso:

```bash
kubectl apply -f deployment-nginx.yaml
```

√â esperado que ocorra um erro nesse momento, pois ainda n√£o configuramos a rota que ser√° respons√°vel por processar a solicita√ß√£o de admiss√£o.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1731883525024/5e3184da-023d-4584-96a1-985ec89bef26.png align="center")

# Servi√ßo de admiss√£o da requisi√ß√£o.

Vamos iniciar a cria√ß√£o de uma API em Go utilizando o framework **Gin** e as depend√™ncias necess√°rias para manipular objetos da API do Kubernetes. Para configurar o ambiente, execute os seguintes comandos:

```bash
go mod init github.com/meurepositorio/admission_webhook
go get github.com/gin-gonic/gin
go get k8s.io/api
go get k8s.io/apimachinery 
```

A l√≥gica do nosso endpoint, respons√°vel por processar as requisi√ß√µes de admiss√£o, pode ser expressa da seguinte forma:

```go
package handlers

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	"github.com/gin-gonic/gin"
	v1 "k8s.io/api/admission/v1"
	appsv1 "k8s.io/api/apps/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const MAX_CPU_VALUE int64 = 100
const MAX_MEMORY_VALUE int64 = 250
const MAX_REPLICAS int32 = 2

// validateResourceContainers validates the CPU and memory resource requests of containers in a deployment.
// It checks if the CPU and memory values provided in the deployment's containers are within the allowed limits.
// If any of the values exceed the maximum limits, an error is returned.
// The function takes a deployment object as input and iterates over the containers in the deployment's template.
// It retrieves the CPU and memory values from the container's resource requests and compares them with the maximum limits.
// If any value exceeds the limit, an error message is returned with the corresponding resource type and value.
// If all values are within the limits, nil is returned.
func validateResourceContainers(deployment appsv1.Deployment) error {
	for _, container := range deployment.Spec.Template.Spec.Containers {
		cpuValue := container.Resources.Requests.Cpu().Value()
		memoryValue := container.Resources.Requests.Memory().Value()
		if cpuValue > MAX_CPU_VALUE {
			return fmt.Errorf("cpu request is too high, the maximum value is %f and you provided %f", MAX_CPU_VALUE, cpuValue)
		}

		if memoryValue > MAX_MEMORY_VALUE {
			return fmt.Errorf("memory request is too high, the maximum value is %f and you provided %f", MAX_MEMORY_VALUE, memoryValue)
		}
	}
	return nil
}

// validateReplicasContainer validates the number of replicas in a deployment.
// It checks if the number of replicas provided in the deployment is within the allowed limit.
// If the number of replicas exceeds the maximum limit, an error is returned.
// The function takes a deployment object as input and compares the number of replicas with the maximum limit.
// If the number of replicas exceeds the limit, an error message is returned with the provided number of replicas and the maximum limit.
// If the number of replicas is within the limit, nil is returned.
func validateReplicasContainer(deployment appsv1.Deployment) error {
	if *deployment.Spec.Replicas > MAX_REPLICAS {
		return fmt.Errorf("the maximum number of replicas is %d and you provided %d", MAX_REPLICAS, *deployment.Spec.Replicas)
	}
	return nil
}

// admitRequest sets the admission response to allow the request.
// It takes an admission review object as input and sets the response to allowed with the same UID as the request.
// The modified admission review object is returned.
func admitRequest(admissionReview *v1.AdmissionReview) *v1.AdmissionReview {
	admissionReview.Response = &v1.AdmissionResponse{
		Allowed: true,
		UID:     admissionReview.Request.UID,
		Result: &metav1.Status{ 
			Status: "Success",
			 Message: "The deployment is valid",
		},
	}
	return admissionReview
}

func rejectRequest(admissionReview *v1.AdmissionReview, message string) *v1.AdmissionReview {
	admissionReview.Response = &v1.AdmissionResponse{
		Allowed: false,
		Result: &metav1.Status{ 
			Status: "Failure",
			Message: message,
		},
		UID: admissionReview.Request.UID,
	}

	return admissionReview;
}

// validateDeploymentHandler is the handler function for validating a deployment.
// It takes a Gin context as input and validates the deployment in the request body.
// If the deployment is valid, an admission review with allowed status is returned.
// If the deployment is invalid, an error response is returned.
func ValidateDeploymentHandler(context *gin.Context) {

	jsonAdmission, err := io.ReadAll(context.Request.Body)
	if err != nil {
		context.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	incomeAdmissionReview := &v1.AdmissionReview{}

	err = json.Unmarshal(jsonAdmission, incomeAdmissionReview)
	if err != nil {
		rejectedAdmissionReview := rejectRequest(incomeAdmissionReview, err.Error())
		context.JSON(http.StatusBadRequest, rejectedAdmissionReview)
		return
	}

	deployment := appsv1.Deployment{}
	err = json.Unmarshal(incomeAdmissionReview.Request.Object.Raw, &deployment)
	if err != nil {
	    rejectedAdmissionReview := rejectRequest(incomeAdmissionReview, err.Error())
		context.JSON(http.StatusBadRequest, rejectedAdmissionReview)
		return
	}

	err = validateResourceContainers(deployment)
	if err != nil {
		rejectedAdmissionReview := rejectRequest(incomeAdmissionReview, err.Error())
		context.JSON(http.StatusBadRequest, rejectedAdmissionReview)
		return
	}

	err = validateReplicasContainer(deployment)
	if err != nil {
		rejectedAdmissionReview := rejectRequest(incomeAdmissionReview, err.Error())
		context.JSON(http.StatusBadRequest, rejectedAdmissionReview)
		return
	}

	admimittedAdmissionReview := admitRequest(incomeAdmissionReview)
	context.JSON(http.StatusOK, admimittedAdmissionReview)
	return 
}
```

O c√≥digo completo da aplica√ß√£o pode ser conferido no [Github](https://github.com/vanascimento/blog/tree/main/kubernetes_admission_webhook).

Com o servi√ßo devidamente configurado e em execu√ß√£o localmente, utilizando o *ngrok* para expor sua URL p√∫blica, podemos executar o seguinte comando:

```go
kubectl apply -f deployment-nginx.yaml
```

Como o *deployment* do Nginx atende √†s regras estabelecidas, ele ser√° aplicado com sucesso. No entanto, se ajustarmos a solicita√ß√£o de CPU para 200m, nosso webhook de admiss√£o ir√° rejeitar o *deployment*, garantindo o cumprimento das pol√≠ticas definidas.

# Outras ideias de extens√µes:

Al√©m das pol√≠ticas de valida√ß√£o de r√©plicas e limites de CPU e mem√≥ria que abordamos, o Kubernetes oferece diversas outras possibilidades para garantir o controle e a conformidade no seu cluster. Abaixo, apresentamos algumas ideias de regras adicionais que podem ser implementadas atrav√©s de webhooks de valida√ß√£o:

1. **Defini√ß√£o de Horizontal Pod Autoscaler (HPA):**
    
    * **Regra:** Garantir que todos os deployments tenham o HPA configurado, para que o escalonamento autom√°tico dos pods seja habilitado quando necess√°rio.
        
    * **Exemplo de Valida√ß√£o:** O webhook pode verificar se o HPA est√° presente no *deployment* e se as m√©tricas de CPU/mem√≥ria est√£o configuradas corretamente para garantir o escalonamento eficiente.
        
2. **Limita√ß√£o de Recursos de CPU e Mem√≥ria:**
    
    * **Regra:** Definir limites m√°ximos e m√≠nimos para o uso de CPU e mem√≥ria em containers.
        
    * **Exemplo de Valida√ß√£o:** O webhook pode ser configurado para garantir que os containers n√£o ultrapassem limites pr√©-estabelecidos de recursos, evitando que um container monopolize a capacidade do n√≥.
        
3. **Pol√≠tica de Uso de Imagens:**
    
    * **Regra:** Garantir que os containers utilizem imagens de reposit√≥rios aprovados e verificados.
        
    * **Exemplo de Valida√ß√£o:** O webhook pode rejeitar o *deployment* caso a imagem do container n√£o esteja em uma lista de imagens aprovadas ou n√£o possua uma tag espec√≠fica (como `stable` ou `latest`).
        
4. **Uso de ServiceAccount Padr√£o:**
    
    * **Regra:** Garantir que os deployments utilizem ServiceAccounts espec√≠ficas para minimizar os privil√©gios concedidos aos pods.
        
    * **Exemplo de Valida√ß√£o:** O webhook pode verificar se o *deployment* est√° usando a ServiceAccount correta e rejeitar aqueles que utilizam a ServiceAccount padr√£o ou n√£o possuem nenhuma configurada.
        
5. **Controle de Acessos (RBAC):**
    
    * **Regra:** Assegurar que os pods estejam configurados com permiss√µes adequadas de acesso aos recursos do cluster.
        
    * **Exemplo de Valida√ß√£o:** O webhook pode validar se os pods est√£o utilizando pol√≠ticas de RBAC que concedem apenas as permiss√µes m√≠nimas necess√°rias, refor√ßando o princ√≠pio do menor privil√©gio.
        
6. **Pol√≠tica de Nomes de Recursos:**
    
    * **Regra:** Validar que os nomes de *deployments*, *pods*, e outros recursos estejam em conformidade com uma conven√ß√£o de nomenclatura espec√≠fica.
        
    * **Exemplo de Valida√ß√£o:** O webhook pode garantir que os nomes de recursos sigam um padr√£o, como a inclus√£o de prefixos para identificar o ambiente (e.g., `dev`, `staging`, `prod`) ou o time respons√°vel.
        
7. **Regras de Seguran√ßa (PodSecurityPolicy ou PSP):**
    
    * **Regra:** Garantir que os pods sigam pol√≠ticas de seguran√ßa, como a proibi√ß√£o de containers rodando como root ou com permiss√µes excessivas.
        
    * **Exemplo de Valida√ß√£o:** O webhook pode ser configurado para verificar configura√ß√µes de seguran√ßa do pod, garantindo que apenas containers com permiss√µes restritas possam ser executados.
        
8. **Estrutura de NetworkPolicies:**
    
    * **Regra:** Assegurar que todos os *deployments* tenham as NetworkPolicies adequadas configuradas para controlar o tr√°fego de rede entre os pods.
        
    * **Exemplo de Valida√ß√£o:** O webhook pode garantir que a comunica√ß√£o entre os pods seja restrita apenas ao necess√°rio, bloqueando acessos indesejados ou vulner√°veis.
        

# Conclus√£o

Neste post, exploramos como o Kubernetes pode ser estendido para garantir conformidade e controle sobre os recursos criados dentro do cluster. Implementamos um webhook de valida√ß√£o que aplica pol√≠ticas espec√≠ficas em tempo de admiss√£o, mostrando como √© poss√≠vel automatizar e refor√ßar boas pr√°ticas sem depender exclusivamente de acordos manuais.

Essa abordagem destaca a flexibilidade e o poder do Kubernetes em cen√°rios complexos, permitindo que clusters sejam gerenciados de forma mais eficiente, segura e escal√°vel. Voc√™ pode adaptar esse exemplo para aplicar outras pol√≠ticas conforme as necessidades do seu ambiente, ampliando ainda mais o controle e a governan√ßa sobre os seus recursos.

Se voc√™ achou √∫til este guia ou tem sugest√µes para melhorias, sinta-se √† vontade para compartilhar nos coment√°rios! üöÄ